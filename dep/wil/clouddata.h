// Windows Internal Libraries (wil)
//
// Cloud Data Store documentation and usage guidelines:
// http://aka.ms/CloudDataStore
//
// Cloud Data Store Partners alias (CDSPart):
// http://idwebelements/GroupManagement.aspx?Group=cdspart&Operation=join  (one-click join)
//
// wil Usage Guidelines:
// https://microsoft.sharepoint.com/teams/osg_development/Shared%20Documents/Windows%20Internal%20Libraries%20for%20C++%20Usage%20Guide.docx?web=1
//
// wil Discussion Alias (wildisc):
// http://idwebelements/GroupManagement.aspx?Group=wildisc&Operation=join  (one-click join)
//
//! @file
//! C++ Cloud Data Store API that encapsulates the Cloud Data Store APIs and Bond (de)serialization of cloud data. See http://aka.ms/CloudDataStore for detailed examples and usage information.

#pragma once
#include <memory>
#include <winstring.h>
#include "result.h"
#include "resource.h"
#include "tracelogging.h"
#include "functional.h"
#include "com.h"
#include <WRL/event.h>
#include <bond/core/bond.h>
#include <windows.internal.storage.cloud.h>
#include <robuffer.h>
#include <roapi.h>
#include <ppltasks.h>
#include <windows.data.platform_types.h>

namespace wil
{
    /// @cond
    namespace details
    {
        // The CDS header itself provides some telemetry because:
        //   1. It is the only place in the stack that is aware of Bond serialization/deserialization failures so those are captured using these events.
        //   2. It is the "top level" component in the stack so it is the best place to capture end-to-end performace data.
        // Otherwise, this data should be kept minimal since other information can be inferred from events lower in the stack.
        // To corrolate these events with other providers, use the value of the "StoreIdFormed" event's "storeId" parameter.
        // TODO: MSFT:6625379 -- Do not use activities here to reduce size.
        class cloud_store_telemetry : public wil::TraceLoggingProvider
        {
            // {26517d41-dbd0-5fb8-b621-80ae99572263} generated by tlgguid.exe
            IMPLEMENT_TRACELOGGING_CLASS(::wil::details::cloud_store_telemetry, "Microsoft.Windows.Shell.CloudStore.Public", (0x26517d41, 0xdbd0, 0x5fb8, 0xb6, 0x21, 0x80, 0xae, 0x99, 0x57, 0x22, 0x63));

        public:
            BEGIN_MEASURES_ACTIVITY_CLASS(Load)
                DEFINE_ACTIVITY_START(PCSTR typeName, UINT32 options)
                {
                    TraceLoggingClassWriteStart(Save,
                        TraceLoggingString(typeName, "typeName"),
                        TraceLoggingUInt32(options, "options"));
                }
                DEFINE_TAGGED_MEASURES_EVENT_PARAM1(StoreIdFormed, PCWSTR, storeId)
            END_ACTIVITY_CLASS();

            BEGIN_MEASURES_ACTIVITY_CLASS(Save)
                DEFINE_ACTIVITY_START(PCSTR typeName)
                {
                    TraceLoggingClassWriteStart(Save,
                        TraceLoggingString(typeName, "typeName"));
                }
                DEFINE_TAGGED_MEASURES_EVENT_PARAM1(StoreIdFormed, PCWSTR, storeId)
            END_ACTIVITY_CLASS();

            BEGIN_MEASURES_ACTIVITY_CLASS(Delete)
                DEFINE_ACTIVITY_START(PCSTR typeName)
                {
                    TraceLoggingClassWriteStart(Delete,
                        TraceLoggingString(typeName, "typeName"));
                }
                DEFINE_TAGGED_MEASURES_EVENT_PARAM1(StoreIdFormed, PCWSTR, storeId)
            END_ACTIVITY_CLASS();
        };

        template<typename T>
        inline wil::com_ptr<T> ActivateInstance(PCWSTR acid)
        {
            HSTRING_HEADER stringHeader;
            HSTRING string;
            THROW_IF_FAILED(WindowsCreateStringReference(acid, static_cast<UINT32>(wcslen(acid)), &stringHeader, &string));
            
            wil::com_ptr<IInspectable> instance;
            THROW_IF_FAILED(RoActivateInstance(string, &instance));
            return instance.query<T>();
        }

        template<typename T>
        inline wil::com_ptr<T> GetActivationFactory(PCWSTR acid)
        {
            HSTRING_HEADER stringHeader;
            HSTRING string;
            THROW_IF_FAILED(WindowsCreateStringReference(acid, static_cast<UINT32>(wcslen(acid)), &stringHeader, &string));

            wil::com_ptr<T> activationFactory;
            THROW_IF_FAILED(RoGetActivationFactory(string, IID_PPV_ARGS(&activationFactory)));
            return activationFactory;
        }

        // PPL does not allow mutable lamdas, so calling a non-const method on a captured member is not allowed.
        // This function works-around the issue by casting-off the const that was applied by the capture to prevent unnecessary copies.
        template<typename T>
        T& convert_to_mutable(const T& captured)
        {
            return *const_cast<T*>(&captured);
        }

        class runtime_init_wrapper final
        {
        public:
            runtime_init_wrapper(const runtime_init_wrapper&) = delete;
            runtime_init_wrapper& operator=(const runtime_init_wrapper&) = delete;

            runtime_init_wrapper(RO_INIT_TYPE flags)
            {
                THROW_IF_FAILED(Windows::Foundation::Initialize(flags));
            }

            ~runtime_init_wrapper()
            {
                Windows::Foundation::Uninitialize();
            }
        };

        inline wil::com_ptr<Windows::Internal::Storage::Cloud::ICloudStore> __stdcall CreateCloudStoreDefault()
        {
            return details::ActivateInstance<Windows::Internal::Storage::Cloud::ICloudStore>(RuntimeClass_Windows_Internal_Storage_Cloud_CloudStore);
        }

        inline wil::com_ptr<Windows::Internal::Storage::Cloud::Metadata::ITypeServices> __stdcall CreateTypeServicesDefault()
        {
            return details::ActivateInstance<Windows::Internal::Storage::Cloud::Metadata::ITypeServices>(RuntimeClass_Windows_Internal_Storage_Cloud_Metadata_TypeServices);
        }

#ifdef UNIT_TESTING
        __declspec(selectany) wil::com_ptr<Windows::Internal::Storage::Cloud::ICloudStore>(__stdcall *g_createCloudStore)() = CreateCloudStoreDefault;
        __declspec(selectany) wil::com_ptr<Windows::Internal::Storage::Cloud::Metadata::ITypeServices>(__stdcall *g_createTypeServices)() = CreateTypeServicesDefault;
#define __WI_CREATE_CLOUD_STORE() (details::g_createCloudStore())
#define __WI_CREATE_TYPE_SERVICES() (details::g_createTypeServices())
#else
#define __WI_CREATE_CLOUD_STORE() (details::CreateCloudStoreDefault())
#define __WI_CREATE_TYPE_SERVICES() (details::CreateTypeServicesDefault())
#endif

        class shared_cloud_store_state final
        {
        public:
            shared_cloud_store_state() = default;
            shared_cloud_store_state(const shared_cloud_store_state&) = delete;
            shared_cloud_store_state& operator =(const shared_cloud_store_state&) = delete;

            const wil::com_ptr<Windows::Internal::Storage::Cloud::Metadata::ITypeServices>& get_type_services()
            {
                if (!m_typeServices)
                {
                    auto newInstance = __WI_CREATE_TYPE_SERVICES();
                    auto lock = m_lock.lock_exclusive();
                    if (!m_typeServices)
                    {
                        m_typeServices = std::move(newInstance);
                    }
                }
                return m_typeServices;
            }

            const wil::com_ptr<Windows::Internal::Storage::Cloud::ICloudStore>& get_cloud_store()
            {
                if (!m_cloudStore)
                {
                    auto newInstance = __WI_CREATE_CLOUD_STORE();
                    auto lock = m_lock.lock_exclusive();
                    if (!m_cloudStore)
                    {
                        m_cloudStore = std::move(newInstance);
                    }
                }
                return m_cloudStore;
            }

            const wil::com_ptr<Windows::Storage::Streams::IBufferFactory>& get_buffer_factory()
            {
                if (!m_bufferFactory)
                {
                    auto newInstance = GetActivationFactory<Windows::Storage::Streams::IBufferFactory>(RuntimeClass_Windows_Storage_Streams_Buffer);
                    auto lock = m_lock.lock_exclusive();
                    if (!m_bufferFactory)
                    {
                        m_bufferFactory = std::move(newInstance);
                    }
                }
                return m_bufferFactory;
            }

        private:
            wil::srwlock m_lock;
            wil::com_ptr<Windows::Internal::Storage::Cloud::Metadata::ITypeServices> m_typeServices;
            wil::com_ptr<Windows::Internal::Storage::Cloud::ICloudStore> m_cloudStore;
            wil::com_ptr<Windows::Storage::Streams::IBufferFactory> m_bufferFactory;
        };

        class versioned_buffer final
        {
        public:
            versioned_buffer() = default;
            versioned_buffer(_In_opt_ Windows::Storage::Streams::IBuffer* buffer, UINT64 version) :
                m_buffer(buffer),
                m_version(version)
            {
            }

            versioned_buffer(_In_opt_ Windows::Internal::Storage::Cloud::ICloudStoreData* cloudStoreData)
            {
                if (cloudStoreData)
                {
                    THROW_IF_FAILED(cloudStoreData->get_Data(&m_buffer));
                    THROW_IF_FAILED(cloudStoreData->get_Version(&m_version));
                }
            }

            versioned_buffer(const versioned_buffer&) = default;
            versioned_buffer(versioned_buffer&&) = default;
            versioned_buffer& operator =(const versioned_buffer&) = default;
            versioned_buffer& operator =(versioned_buffer&&) = default;

            const wil::com_ptr<Windows::Storage::Streams::IBuffer>& buffer() const { return m_buffer; }
            UINT64 version() const { return m_version; }

        private:
            wil::com_ptr<Windows::Storage::Streams::IBuffer> m_buffer;
            UINT64 m_version = 0;
        };

        class cloud_store_data_watcher_t final
        {
        public:
            cloud_store_data_watcher_t(
                _In_ Windows::Internal::Storage::Cloud::ICloudStoreDataWatcher* watcher,
                _In_ Windows::Foundation::ITypedEventHandler<Windows::Internal::Storage::Cloud::CloudStoreDataWatcher*, HSTRING>* callback) :
                m_eventSource(watcher),
                m_callback(callback)
            {
                THROW_IF_FAILED(m_eventSource->add_DataChanged(m_callback.get(), &m_token));
            }

            ~cloud_store_data_watcher_t()
            {
                if (m_token.value != 0)
                {
                    m_eventSource->remove_DataChanged(m_token);
                }
            }

        private:
            wil::com_ptr<Windows::Internal::Storage::Cloud::ICloudStoreDataWatcher> m_eventSource;
            EventRegistrationToken m_token;
            wil::com_ptr<Windows::Foundation::ITypedEventHandler<Windows::Internal::Storage::Cloud::CloudStoreDataWatcher*, HSTRING>> m_callback;
        };

        enum class callback_notification_states
        {
            none                              = 0x0000,
            needsCachedDataNotification       = 0x0001,
            cachedDataNotificationInProgress  = 0x0002,
            needsChangeNotification           = 0x0004,
        };
        DEFINE_ENUM_FLAG_OPERATORS(callback_notification_states);
    } // namespace details
    /// @endcond

    /** A reference to another item stored by the Cloud Data Store.
    @tparam TData The Bond data type being referenced.*/
    template<typename TRef> using cloud_store_data_reference = Windows::Data::Platform::ItemReference<TRef>;

    /** Creates a new reference to an instance of the specified type.
    A cloud_store_data_reference can be used as a member of a Bond structure to allow it to reference other data that is not included in the struct.
    This allows the referenced data to be loaded and saved independently.  Use make_cloud_store_data_reference to create a reference to a new instance
    of data and save the reference in another struct so that it can be accessed later.
    @tparam TData The Bond data type being referenced.
    @param name If a specific name can be determined without access to the referencing Bond structure, it can be specified as a parameter.  This is not typical -- most callers will not pass a name and should use a generated one by default.
    @result A reference to a TData type that can be stored in the Cloud Data Store.*/
    template<typename TData>
    cloud_store_data_reference<TData> make_cloud_store_data_reference(_In_opt_ PCWSTR name = nullptr)
    {
        static_assert(bond::is_bond_type<TData>::value, "Type must be a Bond type (generated by the Bond compiler).");

        enum class data_reference_type
        {
            name = L'n',
            guid = L'g',
        };

        cloud_store_data_reference<TData> instance;
        if (name)
        {
            std::wstring fullName;
            fullName.reserve(wcslen(name) + 2);
            fullName.append(1, static_cast<wchar_t>(data_reference_type::name));
            fullName.append(name);
            instance.referenceName = std::move(fullName);
        }
        else
        {
            GUID guid;
            WI_VERIFY(SUCCEEDED(CoCreateGuid(&guid)));
            wchar_t guidString[41];
            guidString[0] = static_cast<wchar_t>(data_reference_type::guid);
            WI_VERIFY(StringFromGUID2(guid, (guidString + 1), (ARRAYSIZE(guidString) - 1)) != 0);
            instance.referenceName = guidString;
        }
        return instance;
    }

    /** Represents a data item stored in the Cloud Data Store.
    This class is a subclass of the Bond-generated structures and adds additional metadata that is necessary for storage in the cloud.
    Unsealed classes are required by the Cloud Data Store API.
    @tparam TData The Bond data type being accessed.*/
    template<typename TData>
    class cloud_store_data final :
        public TData
    {
        friend class cloud_store;
        static_assert(bond::is_bond_type<TData>::value, "Type must be a Bond type (generated by the Bond compiler).");

    public:
        cloud_store_data() = default;

        //! \{
        cloud_store_data(const cloud_store_data&) = default;
        cloud_store_data(cloud_store_data&&) = default;
        cloud_store_data& operator =(const cloud_store_data&) = default;
        cloud_store_data& operator =(cloud_store_data&&) = default;
        //! \}

        /** Returns false if the data was loaded from the cloud.
        This is used to determine if the data existed in cloud, or if the data did not exist and the structure contains the
        default values defined in Bond.
        This value will be set when the item is constructed by calling cloud_store::load.
        If the class is instantiated with the default constructor, it will be false.
        If no value was in the local store and cached_only load was requested this will also be false.
        @result True if the data item was not loaded from the cloud and contains the default structure's values, otherwise false.*/
        bool is_default() const { return m_isDefault; }

        /** Returns the version ID of the data that was loaded from the store.
        Version IDs are opaque values, but can be compared to see which version of a loaded item is more recent.
        @result The version number of the loaded data.  If this instance was not loaded by calling cloud_store::load, the value will be 0.*/
        UINT64 get_version() const { return m_versionedBuffer.version(); }

    private:
        details::versioned_buffer m_versionedBuffer;
        bool m_updateAllowed = true;
        bool m_isDefault = true;
    };

    //! Flags that can be passed to cloud_store::load or cloud_store::load_async to control load behaviors.
    enum class cloud_store_load_options
    {
        none         = 0x0000, //!< Read-only by default (lower memory overhead than allow_update).
        cached_only  = 0x0001, //!< Do not download new data if it is available, instead only return any locally cached data.
        allow_update = 0x0002, //!< Allows updates of data (cloud_store::save will fail-fast if this flag is not passed when the data is loaded).
    };
    /// @cond
    DEFINE_ENUM_FLAG_OPERATORS(cloud_store_load_options);
    /// @endcond

    //! Operations that can be notified by calling cloud_store::subscribe.
    enum class cloud_store_change_types
    {
        loaded_from_cache  = 0x0001, //!< Notify that cached data has been loaded from local cache.
        cloud_data_changed = 0x0002, //!< Notify that a change to the data has been detected.
        cloud_data_loaded  = 0x0004, //!< Notify that changed data has been been downloaded.
        operation_failed   = 0x0008, //!< When combined with another flag, notifies that an operation failed.
        all_states         = loaded_from_cache | cloud_data_changed | cloud_data_loaded | operation_failed, //!< Notify of all state changes.
    };
    /// @cond
    DEFINE_ENUM_FLAG_OPERATORS(cloud_store_change_types);
    /// @endcond

    /** RAII wrapper over the Cloud Data Store event source.
    Instances of this class are returned by calling cloud_store::subscribe.  The lifetime of the instance controls the ability to recieve events.*/
    typedef std::unique_ptr<details::cloud_store_data_watcher_t> unique_cloud_store_data_watcher;

    /** Contains information about the result of a cloud_store::save or cloud_store::save_async operation.
    Instances of this class are returned by calling cloud_store::save or cloud_store::save_async.*/
    class cloud_store_save_result final
    {
    public:
        /// @cond
        cloud_store_save_result() = default;

        cloud_store_save_result(UINT64 newVersion) :
            m_newVersion(newVersion)
        {
        }
        /// @endcond

        //! \{
        cloud_store_save_result(const cloud_store_save_result&) = default;
        cloud_store_save_result& operator =(const cloud_store_save_result&) = default;
        cloud_store_save_result(cloud_store_save_result&&) = default;
        cloud_store_save_result& operator =(cloud_store_save_result&&) = default;
        //! \}

        /** Returns the version number of the stored data
        @result The version number of the stored data.*/
        UINT64 get_version() const { return m_newVersion; }

    private:
        UINT64 m_newVersion = 0;
    };

    /** Provides access to cloud storage for persisting Bond-schematized data in the user's cloud profile.
    This class provides functionality for loading, saving, and deleting data in the cloud as well as watching the cloud data for changes.
    Prefer re-using the object as reusing a single instance avoids the performance costs of initializing multiple instances.
    This object holds COM references to internal Cloud Data Store interfaces, so it should not be used as a global object.
    This class provides both synchronous and asynchronous APIs for accessing cloud data.  The synchronous APIs are offered as a
    convenience for background threads and will fail-fast if called from a UI thread.  Use the asynchronous APIs from UI threads instead.*/
    class cloud_store final
    {
    public:
        cloud_store()
        {
            // Attempt to prevent use as a global since this object holds COM references.
            FAIL_FAST_IMMEDIATE_IF_IN_LOADER_CALLOUT();
            m_sharedState = std::make_shared<details::shared_cloud_store_state>();
        }

        //! \{
        cloud_store(const cloud_store&) = default;
        cloud_store& operator =(const cloud_store&) = default;
        cloud_store(cloud_store&&) = default;
        cloud_store& operator =(cloud_store&&) = default;
        //! \}

        /** Synchronously loads the specified Bond type from the Cloud Data Store.
        Used to load instances of types that are not referenced elsewhere in the schema.
        If this data will be subsequenlty modified and saved in the Cloud Data Store, then pass cloud_store_load_options::allow_update.
        This method will fail-fast if called from a UI thread. Use cloud_store::load_async from UI threads instead.
        This method only applies to types that are not attributed with CloudData.MultipleInstances("true") in the Bond schema.
        @tparam TData The type of data to load.
        @param[in] options Options that control the load's behavior (by default, returns a read-only instance).
        @result The loaded data.*/
        template<typename TData>
        cloud_store_data<TData> load(cloud_store_load_options options = cloud_store_load_options::none)
        {
            return load_internal<TData>(options, nullptr);
        }

        /** Synchronously loads the specified instance of a Bond type from the Cloud Data Store.
        Used to load a specific instance of a type that supports multiple instances.
        If this data will be subsequenlty modified and saved in the Cloud Data Store, then pass cloud_store_load_options::allow_update.
        This method will fail-fast if called from a UI thread. Use cloud_store::load_async from UI threads instead.
        This method only applies to types that are attributed with CloudData.MultipleInstances("true") in the Bond schema.
        @tparam TData The type of data to load.
        @param[in] id The reference to the data of type TData.  Typically this value returned by a previous call to clouddata::load or clouddata::load_async.
        @param[in] options Options that control the load's behavior (by default, returns a read-only instance).
        @result The loaded data.*/
        template<typename TData>
        cloud_store_data<TData> load(const cloud_store_data_reference<TData>& id, cloud_store_load_options options = cloud_store_load_options::none)
        {
            return load_internal(options, &id);
        }

        /** Asynchronously loads the specified Bond type from the Cloud Data Store.
        Used to load instances of types that are not referenced elsewhere in the schema.
        If this data will be subsequenlty modified and saved in the Cloud Data Store, then pass cloud_store_load_options::allow_update.
        Since it is asynchronous, this method can be called by both UI threads or background threads.
        This method only applies to types that are not attributed with CloudData.MultipleInstances("true") in the Bond schema.
        @tparam TData The type of data to load.
        @param[in] options Options that control the load's behavior (by default, returns a read-only instance).
        @result A concurrency::task that returns the loaded data when complete.*/
        template<typename TData>
        concurrency::task<cloud_store_data<TData>> load_async(cloud_store_load_options options = cloud_store_load_options::none)
        {
            return load_async_internal<TData>(options, nullptr);
        }

        /** Asynchronously loads the specified instance of a Bond type from the Cloud Data Store.
        Used to load a specific instance of a type that supports multiple instances.
        If this data will be subsequenlty modified and saved in the Cloud Data Store, then pass cloud_store_load_options::allow_update.
        Since it is asynchronous, this method can be called by both UI threads or background threads.
        This method only applies to types that are attributed with CloudData.MultipleInstances("true") in the Bond schema.
        @tparam TData The type of data to load.
        @param[in] id The reference to the data of type TData.  Typically this value returned by a previous call to clouddata::load or clouddata::load_async.
        @param[in] options Options that control the load's behavior (by default, returns a read-only instance).
        @result A concurrency::task that returns the loaded data when complete.*/
        template<typename TData>
        concurrency::task<cloud_store_data<TData>> load_async(const cloud_store_data_reference<TData>& id, cloud_store_load_options options = cloud_store_load_options::none)
        {
            return load_async_internal(options, &id);
        }

        /** Synchronously saves the specified Bond type from the Cloud Data Store.
        Use this overload to save instances of types that are not referenced elsewhere.
        This method will fail-fast if called from a UI thread. Use cloud_store::save_async from UI threads instead.
        This method only applies to types that not are attributed with CloudData.MultipleInstances("true") in the Bond schema.
        @tparam TData The type of data to save.
        @param[in] item The data item of type TData to save (typically returned from a previous call to clouddata::load or clouddata::load_async.
        @result A cloud_store_save_result describing the result of the storage operation.*/
        template<typename TData>
        cloud_store_save_result save(const cloud_store_data<TData>& item)
        {
            return save_internal<TData>(item, nullptr);
        }

        /** Synchronously saves the specified instance of a Bond type from the Cloud Data Store.
        Use this overload to save instances of types that are referenced elsewhere.
        This method will fail-fast if called from a UI thread. Use cloud_store::save_async from UI threads instead.
        This method only applies to types that are attributed with CloudData.MultipleInstances("true") in the Bond schema.
        @tparam TData The type of data to save.
        @param[in] item The data item of type TData to save (typically returned from a previous call to clouddata::load or clouddata::load_async.
        @param[in] id The reference to the data of type TData.
        @result A cloud_store_save_result describing the result of the storage operation.*/
        template<typename TData>
        cloud_store_save_result save(const cloud_store_data<TData>& item, const cloud_store_data_reference<TData>& id)
        {
            return save_internal(item, &id);
        }

        /** Asynchronously saves the specified Bond type from the Cloud Data Store.
        Use this overload to save instances of types that are not referenced elsewhere.
        Since it is asynchronous, this method can be called by both UI threads or background threads.
        This method only applies to types that are not attributed with CloudData.MultipleInstances("true") in the Bond schema.
        @tparam TData The type of data to save.
        @param[in] item The data item of type TData to save (typically returned from a previous call to clouddata::load or clouddata::load_async.
        @result A concurrency::task containing a cloud_store_save_result that describes the result of the operation.*/
        template<typename TData>
        concurrency::task<cloud_store_save_result> save_async(const cloud_store_data<TData>& item)
        {
            return save_async_internal<TData>(item, nullptr);
        }

        /** Asynchronously saves the specified instance of a Bond type from the Cloud Data Store.
        Use this overload to save instances of types that are referenced elsewhere.
        Since it is asynchronous, this method can be called by both UI threads or background threads.
        This method only applies to types that are attributed with CloudData.MultipleInstances("true") in the Bond schema.
        @tparam TData The type of data to save.
        @param[in] item The data item of type TData to save (typically returned from a previous call to clouddata::load or clouddata::load_async.
        @param[in] id The reference to the data of type TData.
        @result A concurrency::task containing a cloud_store_save_result that describes the result of the operation.*/
        template<typename TData>
        concurrency::task<cloud_store_save_result> save_async(const cloud_store_data<TData>& item, const cloud_store_data_reference<TData>& id)
        {
            return save_async_internal(item, &id);
        }

        /** Synchronously deletes the specified Bond type from the Cloud Data Store.
        Use this overload to delete instances of types that are not referenced elsewhere in the schema.
        This method will fail-fast if called from a UI thread. Use cloud_store::delete_item_async from UI threads instead.
        This method only applies to types that are not attributed with CloudData.MultipleInstances("true") in the Bond schema.
        @tparam TData The type of data to delete.*/
        template<typename TData>
        void delete_item()
        {
            delete_item_internal<TData>(nullptr);
        }

        /** Synchronously deletes the specified instance of a Bond type from the Cloud Data Store.
        Use this overload to delete instances of types that are referenced elsewhere.
        This method will fail-fast if called from a UI thread. Use cloud_store::delete_item_async from UI threads instead.
        This method only applies to types that are attributed with CloudData.MultipleInstances("true") in the Bond schema.
        @tparam TData The type of data to delete.
        @param[in] id The reference to the data of type TData.*/
        template<typename TData>
        void delete_item(const cloud_store_data_reference<TData>& id)
        {
            delete_item_internal(&id);
        }

        /** Asynchronously deletes the specified Bond type from the Cloud Data Store.
        Use this overload to delete instances of types that are not referenced elsewhere in the schema.
        Since it is asynchronous, this method can be called by both UI threads or background threads.
        This method only applies to types that are not attributed with CloudData.MultipleInstances("true") in the Bond schema.
        @result A concurrency::task that returns when the deletion is complete.*/
        template<typename TData>
        concurrency::task<void> delete_item_async()
        {
            return delete_item_async_internal<TData>(nullptr);
        }

        /** Asynchronously deletes the specified instance of a Bond type from the Cloud Data Store.
        Use this overload to delete instances of types that are not referenced elsewhere in the schema.
        Since it is asynchronous, this method can be called by both UI threads or background threads.
        This method only applies to types that are attributed with CloudData.MultipleInstances("true") in the Bond schema.
        @tparam TData The type of data to delete.
        @param[in] id The reference to the data of type TData.
        @result A concurrency::task that returns when the deletion is complete.*/
        template<typename TData>
        concurrency::task<void> delete_item_async(const cloud_store_data_reference<TData>& id)
        {
            return delete_item_async_internal(&id);
        }

        /** Watch the Cloud Data Store for changes to the specified type.
        Callbacks will occur on a threadpool thread.
        This method only applies to types that are not attributed with CloudData.MultipleInstances("true") in the Bond schema.
        @tparam TData The type of data to watch for changes.
        @param[in] changeTypesToNotify The types of change notifications that should be reported to the callback.
        @param[in] callback The callback function to notify of changes.
        @result A unique_cloud_store_data_watcher that represents the lifetime of the subscription.*/
        template<typename TData>
        unique_cloud_store_data_watcher subscribe(
            cloud_store_change_types changeTypesToNotify,
            std::function<void(cloud_store_change_types state, cloud_store_data<TData>* dataItem)> callback)
        {
            return subscribe_internal<TData>(changeTypesToNotify, nullptr, callback);
        }

        /** Watch the Cloud Data Store for changes to the specified instance of a Bond type.
        Callbacks will occur on a threadpool thread.
        This method only applies to types that are attributed with CloudData.MultipleInstances("true") in the Bond schema.
        @tparam TData The type of data to watch for changes.
        @param[in] changeTypesToNotify The types of change notifications that should be reported to the callback.
        @param[in] id The reference to the data of type TData.
        @param[in] callback The callback function to notify of changes.
        @result A unique_cloud_store_data_watcher that represents the lifetime of the subscription.*/
        template<typename TData>
        unique_cloud_store_data_watcher subscribe(
            cloud_store_change_types changeTypesToNotify,
            const cloud_store_data_reference<TData>& id,
            std::function<void(cloud_store_change_types state, cloud_store_data<TData>* dataItem, const cloud_store_data_reference<TData>& id)> callback)
        {
            auto callbackWithoutId = [idCopy(id), callback](cloud_store_change_types state, cloud_store_data<TData>* dataItem)
            {
                callback(state, dataItem, idCopy);
            };
            return subscribe_internal<TData>(changeTypesToNotify, &id, callbackWithoutId);
        }

    private:
        template<typename TData>
        cloud_store_data<TData> load_internal(cloud_store_load_options options, _In_opt_ const cloud_store_data_reference<TData>* id)
        {
            auto activity = details::cloud_store_telemetry::Load::Start(TData::Schema::metadata.qualified_name.c_str(), static_cast<UINT32>(options));
            auto dataStoreId = validate_and_get_datastore_id(TData::Schema::metadata.qualified_name.c_str(), id);
            activity.StoreIdFormed(WindowsGetStringRawBuffer(dataStoreId.get(), nullptr));
            return load_with_id<TData>(dataStoreId.get(), options, activity);
        }

        template<typename TData>
        concurrency::task<cloud_store_data<TData>> load_async_internal(cloud_store_load_options options, _In_opt_ const cloud_store_data_reference<TData>* id)
        {
            auto activity = details::cloud_store_telemetry::Load::Start(TData::Schema::metadata.qualified_name.c_str(), static_cast<UINT32>(options));
            auto dataStoreId = validate_and_get_datastore_id(TData::Schema::metadata.qualified_name.c_str(), id); // Perform validation on calling thread
            activity.StoreIdFormed(WindowsGetStringRawBuffer(dataStoreId.get(), nullptr));
            return load_with_id_async<TData>(std::move(dataStoreId), options, activity);
        }

        template<typename TData>
        cloud_store_save_result save_internal(const cloud_store_data<TData>& item, _In_opt_ const cloud_store_data_reference<TData>* id)
        {
            auto activity = details::cloud_store_telemetry::Save::Start(TData::Schema::metadata.qualified_name.c_str());
            FAIL_FAST_IF(!item.m_updateAllowed); // load was not called with allow_update
            auto dataStoreId = validate_and_get_datastore_id(TData::Schema::metadata.qualified_name.c_str(), id);
            activity.StoreIdFormed(WindowsGetStringRawBuffer(dataStoreId.get(), nullptr));
            return save_with_id(item, dataStoreId.get(), activity);
        }

        template<typename TData>
        concurrency::task<cloud_store_save_result> save_async_internal(const cloud_store_data<TData>& item, _In_opt_ const cloud_store_data_reference<TData>* id)
        {
            auto activity = details::cloud_store_telemetry::Save::Start(TData::Schema::metadata.qualified_name.c_str());
            FAIL_FAST_IF(!item.m_updateAllowed); // load was not called with allow_update
            auto dataStoreId = validate_and_get_datastore_id(TData::Schema::metadata.qualified_name.c_str(), id);  // Perform validation on calling thread
            activity.StoreIdFormed(WindowsGetStringRawBuffer(dataStoreId.get(), nullptr));
            return save_with_id_async(item, std::move(dataStoreId), activity);
        }

        template<typename TData>
        void delete_item_internal(_In_opt_ const cloud_store_data_reference<TData>* id)
        {
            auto activity = details::cloud_store_telemetry::Delete::Start(TData::Schema::metadata.qualified_name.c_str());
            auto dataStoreId = validate_and_get_datastore_id(TData::Schema::metadata.qualified_name.c_str(), id);
            activity.StoreIdFormed(WindowsGetStringRawBuffer(dataStoreId.get(), nullptr));
            delete_item_with_id(dataStoreId.get(), activity);
        }

        template<typename TData>
        concurrency::task<void> delete_item_async_internal(_In_opt_ const cloud_store_data_reference<TData>* id)
        {
            auto activity = details::cloud_store_telemetry::Delete::Start(TData::Schema::metadata.qualified_name.c_str());
            auto dataStoreId = validate_and_get_datastore_id(TData::Schema::metadata.qualified_name.c_str(), id); // Perform validation on calling thread
            activity.StoreIdFormed(WindowsGetStringRawBuffer(dataStoreId.get(), nullptr));
            return delete_item_with_id_async(std::move(dataStoreId), activity);
        }

        template<typename TData>
        concurrency::task<cloud_store_data<TData>> load_with_id_async(wil::unique_hstring&& dataStoreId, cloud_store_load_options options, _Inout_ details::cloud_store_telemetry::Load& activity)
        {
            wil::shared_hstring dataStoreIdCopy(std::move(dataStoreId));
            return concurrency::create_task([thisCopy(*this), dataStoreIdCopy, options, activity]() -> cloud_store_data<TData>
            {
                auto continuation = details::convert_to_mutable(activity).ContinueOnCurrentThread();
                details::runtime_init_wrapper roInit(RO_INIT_MULTITHREADED);
                return details::convert_to_mutable(thisCopy).load_with_id<TData>(dataStoreIdCopy.get(), options, details::convert_to_mutable(activity));
            });
        }

        template<typename TData>
        concurrency::task<cloud_store_save_result> save_with_id_async(const cloud_store_data<TData>& item, wil::unique_hstring&& dataStoreId, _Inout_ details::cloud_store_telemetry::Save& activity)
        {
            wil::shared_hstring dataStoreIdCopy(std::move(dataStoreId));
            return concurrency::create_task([thisCopy(*this), dataStoreIdCopy, item, activity]() -> cloud_store_save_result
            {
                auto continuation = details::convert_to_mutable(activity).ContinueOnCurrentThread();
                details::runtime_init_wrapper roInit(RO_INIT_MULTITHREADED);
                return details::convert_to_mutable(thisCopy).save_with_id(item, dataStoreIdCopy.get(), details::convert_to_mutable(activity));
            });
        }

        concurrency::task<void> delete_item_with_id_async(wil::unique_hstring&& dataStoreId, _Inout_ details::cloud_store_telemetry::Delete& activity)
        {
            wil::shared_hstring dataStoreIdCopy(std::move(dataStoreId));
            return concurrency::create_task([thisCopy(*this), dataStoreIdCopy, activity]() -> void
            {
                auto continuation = details::convert_to_mutable(activity).ContinueOnCurrentThread();
                details::runtime_init_wrapper roInit(RO_INIT_MULTITHREADED);
                details::convert_to_mutable(thisCopy).delete_item_with_id(dataStoreIdCopy.get(), details::convert_to_mutable(activity));
            });
        }

        template<typename TData>
        cloud_store_data<TData> load_with_id(_In_opt_ HSTRING dataStoreId, cloud_store_load_options options, _Inout_ details::cloud_store_telemetry::Load& activity)
        {
            cloud_store_data<TData> instance = unmarshal<TData>(load_marshaled(dataStoreId, options), options);
            activity.Stop();
            return instance;
        }

        template<typename TData>
        cloud_store_save_result save_with_id(const cloud_store_data<TData>& item, _In_opt_ HSTRING dataStoreId, _Inout_ details::cloud_store_telemetry::Save& activity)
        {
            details::versioned_buffer originalBuffer = item.m_versionedBuffer;
            if (!originalBuffer.buffer())
            {
                // No original was available, so marshal the default values for use as the original.
                // This keeps the version number intract in case it was deleted previously.
                TData defaultInstance;
                originalBuffer = details::versioned_buffer(marshal(defaultInstance).get(), originalBuffer.version());
            }

            auto version = save_marshaled(dataStoreId, originalBuffer, marshal(item).get());
            activity.Stop();
            return version;
        }

        void delete_item_with_id(_In_opt_ HSTRING dataStoreId, details::cloud_store_telemetry::Delete& activity)
        {
            THROW_IF_FAILED(m_sharedState->get_cloud_store()->Delete(dataStoreId));
            activity.Stop();
        }

        template<typename TData>
        unique_cloud_store_data_watcher subscribe_internal(
            cloud_store_change_types changeTypesToNotify,
            _In_opt_ const cloud_store_data_reference<TData>* id,
            std::function<void(cloud_store_change_types state, cloud_store_data<TData>* dataItem)> typedCallback)
        {
            wil::shared_hstring dataStoreId(validate_and_get_datastore_id(TData::Schema::metadata.qualified_name.c_str(), id));

            auto changeNotifyCallback = [typedCallback]()
            {
                try
                {
                    typedCallback(cloud_store_change_types::cloud_data_changed, nullptr);
                }
                catch (...)
                {
                    wil::ResultFromCaughtException(); // Fail-fast if unexpected exception
                }
            };

            auto downloadCallback = [thisCopy(*this), dataStoreId, typedCallback](bool isInitialCacheDownload) mutable
            {
                const cloud_store_load_options loadOptions = isInitialCacheDownload ? (cloud_store_load_options::allow_update | cloud_store_load_options::cached_only) : (cloud_store_load_options::allow_update);
                const cloud_store_change_types toNotify = isInitialCacheDownload ? cloud_store_change_types::loaded_from_cache : cloud_store_change_types::cloud_data_loaded;

                bool loadSuccessful = false;
                try
                {
                    auto activity = details::cloud_store_telemetry::Load::Start(TData::Schema::metadata.qualified_name.c_str(), static_cast<UINT32>(loadOptions));
                    cloud_store_data<TData> item = thisCopy.load_with_id<TData>(dataStoreId.get(), loadOptions, activity);
                    loadSuccessful = true; // Don't notify the callback of failure if the callback failed, only if load failed.
                    typedCallback(toNotify, &item);
                }
                catch (...)
                {
                    wil::ResultFromCaughtException(); // Fail-fast if unexpected exception
                }

                if (!loadSuccessful) 
                {
                    try
                    {
                        typedCallback(toNotify | cloud_store_change_types::operation_failed, nullptr);
                    }
                    catch (...)
                    {
                        wil::ResultFromCaughtException(); // Fail-fast if unexpected exception
                    }
                }
            };
            return subscribe_with_id(dataStoreId.get(), changeTypesToNotify, changeNotifyCallback, downloadCallback);
        }

        unique_cloud_store_data_watcher subscribe_with_id(_In_opt_ HSTRING dataStoreId, cloud_store_change_types changeTypesToNotify, std::function<void()> changeNotifyCallback, std::function<void(bool)> downloadCallback)
        {
            wil::com_ptr<Windows::Internal::Storage::Cloud::ICloudStoreDataWatcher> cloudStoreDataWatcher;
            THROW_IF_FAILED(m_sharedState->get_cloud_store()->CreateWatcher(dataStoreId, &cloudStoreDataWatcher));

            struct shared_callback_data
            {
                wil::srwlock lock;
                details::callback_notification_states state = details::callback_notification_states::none;
            };
            auto sharedData = std::make_shared<shared_callback_data>();

            auto callback = [changeNotifyCallback, downloadCallback, changeTypesToNotify, sharedData]()
            {
                bool notifyCachedData;
                {
                    // If the current state requires notifying with cached data, then now it will be in-progress
                    auto lock = sharedData->lock.lock_exclusive();
                    if (WI_IS_FLAG_SET(sharedData->state, details::callback_notification_states::needsCachedDataNotification))
                    {
                        WI_CLEAR_FLAG(sharedData->state, details::callback_notification_states::needsCachedDataNotification);
                        WI_SET_FLAG(sharedData->state, details::callback_notification_states::cachedDataNotificationInProgress);
                        notifyCachedData = true;
                    }
                    else
                    {
                        notifyCachedData = false;
                    }
                }

                // If the current state requires notifying with cached data, always do that first
                if (notifyCachedData)
                {
                    downloadCallback(true);

                    // Cached data is no longer in progress
                    auto lock = sharedData->lock.lock_exclusive(); 
                    WI_CLEAR_FLAG(sharedData->state, details::callback_notification_states::cachedDataNotificationInProgress);
                }

                // If the current state requires notifying of a change notification, then do that now.
                bool notifyChange;
                {
                    auto lock = sharedData->lock.lock_exclusive();
                    if (WI_IS_FLAG_SET(sharedData->state, details::callback_notification_states::needsChangeNotification) &&
                        WI_IS_FLAG_CLEAR(sharedData->state, details::callback_notification_states::cachedDataNotificationInProgress))
                    {
                        WI_CLEAR_FLAG(sharedData->state, details::callback_notification_states::needsChangeNotification);
                        notifyChange = true;
                    }
                    else
                    {
                        // Another thread is in the process of notifying of cached data.  Skip this notification
                        // and let the thread that is performing the cached data notification also perform the change notification.
                        // This way there is no chance of sending new data before the cached data.
                        notifyChange = false;
                    }
                }

                if (notifyChange)
                {
                    if (WI_IS_FLAG_SET(changeTypesToNotify, cloud_store_change_types::cloud_data_changed))
                    {
                        changeNotifyCallback();
                    }

                    if (WI_IS_FLAG_SET(changeTypesToNotify, cloud_store_change_types::cloud_data_loaded))
                    {
                        downloadCallback(false);
                    }
                }
                return S_OK;
            };

            auto typedEventHandler = Microsoft::WRL::Callback<Windows::Foundation::ITypedEventHandler<Windows::Internal::Storage::Cloud::CloudStoreDataWatcher*, HSTRING>>(
                [callback, sharedData](Windows::Internal::Storage::Cloud::ICloudStoreDataWatcher* /*source*/, HSTRING /*dataStoreId*/) -> HRESULT
                {
                    {
                        auto lock = sharedData->lock.lock_exclusive();
                        WI_SET_FLAG(sharedData->state, details::callback_notification_states::needsChangeNotification);
                    }
                    callback();
                    return S_OK;
                });

            // Acquire lock now so that the callback does not execute before we can determine if cached changes need to be sent.
            auto lock = sharedData->lock.lock_exclusive(); 
            unique_cloud_store_data_watcher watcher(new details::cloud_store_data_watcher_t(cloudStoreDataWatcher.get(), typedEventHandler.Get()));

            boolean isNewDataAvailableInCloud;
            THROW_IF_FAILED(m_sharedState->get_cloud_store()->IsNewDataAvailableInCloud(dataStoreId, &isNewDataAvailableInCloud));
            if (isNewDataAvailableInCloud)
            {
                // New data was already available, potentially before the watcher started.  Need to notify of the change.
                WI_SET_FLAG(sharedData->state, details::callback_notification_states::needsChangeNotification);
            }

            if (WI_IS_FLAG_SET(changeTypesToNotify, cloud_store_change_types::loaded_from_cache))
            {
                // The caller requested that they are notified immediately with any cached data.
                WI_SET_FLAG(sharedData->state, details::callback_notification_states::needsCachedDataNotification);
            }

            // Notify now, if there is a reason to notify.
            if (WI_IS_ANY_FLAG_SET(sharedData->state, details::callback_notification_states::needsChangeNotification | details::callback_notification_states::needsCachedDataNotification))
            {
                concurrency::create_task([callback]()
                    {
                        details::runtime_init_wrapper roInit(RO_INIT_MULTITHREADED);
                        callback();
                    });
            }
            return watcher;
        }

        template<typename TData>
        cloud_store_data<TData> unmarshal(const details::versioned_buffer& versionedBuffer, cloud_store_load_options options)
        {
            cloud_store_data<TData> instance;
            if (WI_IS_FLAG_SET(options, cloud_store_load_options::allow_update))
            {
                // Update is required, store the original to allow merge when save is called.
                instance.m_versionedBuffer = versionedBuffer;
            }
            else
            {
                // Read-only instance requested, only keep the version and reclaim the buffer.
                instance.m_versionedBuffer = details::versioned_buffer(nullptr, versionedBuffer.version());

                // Updates are not allowed using this instance.
                instance.m_updateAllowed = false;
            }
            if (versionedBuffer.buffer())
            {
                bond::InputBuffer inputBuffer = versioned_buffer_to_input_buffer(versionedBuffer);
                Unmarshal(inputBuffer, instance);
                instance.m_isDefault = false;
            }
            return instance;
        }

        template<typename TData>
        wil::com_ptr<Windows::Storage::Streams::IBuffer> marshal(const TData& item)
        {
            bond::OutputBuffer outputBuffer;
            bond::CompactBinaryWriter<bond::OutputBuffer> writer(outputBuffer);
            Marshal(item, writer);
            return output_buffer_to_buffer(outputBuffer);
        }

        details::versioned_buffer load_marshaled(_In_opt_ HSTRING dataStoreId, cloud_store_load_options options)
        {
            wil::com_ptr<Windows::Internal::Storage::Cloud::ICloudStoreData> cloudStoreData;
            THROW_IF_FAILED(m_sharedState->get_cloud_store()->Load(dataStoreId, cloud_cloud_store_load_options(options), &cloudStoreData));
            return details::versioned_buffer(cloudStoreData.get());
        }

        cloud_store_save_result save_marshaled(_In_opt_ HSTRING dataStoreId, const details::versioned_buffer& original, _In_ Windows::Storage::Streams::IBuffer* newData)
        {
            UINT64 newVersion;
            THROW_IF_FAILED(m_sharedState->get_cloud_store()->Save(dataStoreId, original.version(), original.buffer().get(), newData, &newVersion));
            return cloud_store_save_result(newVersion);
        }

        // Note: returned value is only valid as long as passed-in object
        bond::InputBuffer versioned_buffer_to_input_buffer(const details::versioned_buffer& versionedBuffer)
        {
            UINT32 length;
            THROW_IF_FAILED(versionedBuffer.buffer()->get_Length(&length));

            byte* data;
            auto bufferByteAccess = versionedBuffer.buffer().query<Windows::Storage::Streams::IBufferByteAccess>();
            THROW_IF_FAILED(bufferByteAccess->Buffer(&data));

            bond::blob blob(data, length);
            return bond::InputBuffer(blob);
        }

        wil::com_ptr<Windows::Storage::Streams::IBuffer> output_buffer_to_buffer(const bond::OutputBuffer& outputBuffer)
        {
            bond::blob blob = outputBuffer.GetBuffer();
            wil::com_ptr<Windows::Storage::Streams::IBuffer> buffer;
            THROW_IF_FAILED(m_sharedState->get_buffer_factory()->Create(blob.length(), &buffer));

            byte* data;
            auto bufferByteAccess = buffer.query<Windows::Storage::Streams::IBufferByteAccess>();
            THROW_IF_FAILED(bufferByteAccess->Buffer(&data));
            CopyMemory(data, blob.data(), blob.length());
            THROW_IF_FAILED(buffer->put_Length(blob.length()));
            return buffer;
        }

        // Get the fully-qualified ID to pass to the data store.
        template<typename TData>
        wil::unique_hstring validate_and_get_datastore_id(PCSTR qualifiedName, _In_opt_ const cloud_store_data_reference<TData>* instanceId)
        {
            FAIL_FAST_IF(!qualifiedName || (qualifiedName[0] == L'\0'));
            // An empty string would bypass the error checks in CreateDataStoreId since that would look like a valid cloud_store_data_reference,
            // and maps to the same HSTRING representation as nullptr which is valid.  Check for that now.
            // This check is important because constructing the structures incorrectly will result in empty strings.
            FAIL_FAST_IF(instanceId && (instanceId->referenceName.c_str()[0] == L'\0'));
            return get_datastore_id(qualifiedName, (instanceId ? instanceId->referenceName.c_str() : nullptr));
        }

        wil::unique_hstring get_datastore_id(PCSTR qualifiedName, _In_opt_ PCWSTR instanceId)
        {
            wchar_t qualifiedNameWideString[512];
            FAIL_FAST_IF_FAILED(StringCchPrintfW(qualifiedNameWideString, ARRAYSIZE(qualifiedNameWideString), L"%hs", qualifiedName));

            HSTRING_HEADER qualifiedNameStringHeader;
            HSTRING qualifiedNameString;
            THROW_IF_FAILED(WindowsCreateStringReference(qualifiedNameWideString, static_cast<UINT32>(wcslen(qualifiedNameWideString)), &qualifiedNameStringHeader, &qualifiedNameString));

            HSTRING_HEADER instanceIdStringHeader;
            HSTRING instanceIdString = nullptr;
            if (instanceId)
            {
                THROW_IF_FAILED(WindowsCreateStringReference(instanceId, static_cast<UINT32>(wcslen(instanceId)), &instanceIdStringHeader, &instanceIdString));
            }

            wil::unique_hstring dataStoreId;
            THROW_IF_FAILED(m_sharedState->get_type_services()->CreateDataStoreId(qualifiedNameString, instanceIdString, wil::out_param(dataStoreId)));
            return dataStoreId;
        }

        static Windows::Internal::Storage::Cloud::LoadOptions cloud_cloud_store_load_options(cloud_store_load_options options)
        {
            Windows::Internal::Storage::Cloud::LoadOptions result = Windows::Internal::Storage::Cloud::LoadOptions_None;
            if (WI_IS_FLAG_SET(options, cloud_store_load_options::cached_only))
            {
                WI_SET_FLAG(result, Windows::Internal::Storage::Cloud::LoadOptions_LocalOnly);
            }
            return result;
        }

        std::shared_ptr<details::shared_cloud_store_state> m_sharedState;
    }; // class cloud_store
} // namespace wil

#pragma region Conversion routines

/// @cond
// Forward declarations for conversion routines
namespace Windows
{
    namespace Data
    {
        namespace Common
        {
            struct Point;
            struct Rect;
            struct Size;
        }
    }
}

namespace bond
{
    struct GUID;
}
/// @endcond

namespace wil
{
#pragma region Point

    /** Converts a Windows::Data::Common::Point instance to a Win32 POINT structure.
    @tparam T Windows::Data::Common::Point.  This type is typically inferred by the compiler.
    @param[in] input The Windows::Data::Common::Point to convert.
    @result An equivalent Win32 POINT structure.*/
    template<typename T = ::Windows::Data::Common::Point>
    POINT win32_point_from_bond(const T& input)
    {
        POINT output;
        output.x = input.x;
        output.y = input.y;
        return output;
    }

    /** Converts a Win32 POINT structure into a Windows::Data::Common::Point instance.
    @tparam T Windows::Data::Common::Point.  This type is typically inferred by the compiler.
    @param[in] input The Win32 POINT structure to convert.
    @result An equivalent Windows::Data::Common::Point instance.*/
    template<typename T = ::Windows::Data::Common::Point>
    T bond_point_from_win32(const POINT& input)
    {
        ::Windows::Data::Common::Point output;
        output.x = input.x;
        output.y = input.y;
        return output;
    }

#pragma endregion // Point
#pragma region Rect

    /** Converts a Windows::Data::Common::Rect instance to a Win32 RECT structure.
    @tparam T Windows::Data::Common::Rect.  This type is typically inferred by the compiler.
    @param[in] input The Windows::Data::Common::Rect to convert.
    @result An equivalent Win32 RECT structure.*/
    template<typename T = ::Windows::Data::Common::Rect>
    RECT win32_rect_from_bond(const T& input)
    {
        RECT output;
        output.left = input.left;
        output.top = input.top;
        output.right = input.right;
        output.bottom = input.bottom;
        return output;
    }

    /** Converts a Win32 RECT structure into a Windows::Data::Common::Rect instance.
    @tparam T Windows::Data::Common::Rect.  This type is typically inferred by the compiler.
    @param[in] input The Win32 RECT structure to convert.
    @result An equivalent Windows::Data::Common::Rect instance.*/
    template<typename T = ::Windows::Data::Common::Rect>
    T bond_rect_from_win32(const RECT& input)
    {
        ::Windows::Data::Common::Rect output;
        output.left = input.left;
        output.top = input.top;
        output.right = input.right;
        output.bottom = input.bottom;
        return output;
    }

#pragma endregion // Rect
#pragma region Size

    /** Converts a Windows::Data::Common::Size instance to a Win32 SIZE structure.
    @tparam T Windows::Data::Common::Size.  This type is typically inferred by the compiler.
    @param[in] input The Windows::Data::Common::Size to convert.
    @result An equivalent Win32 SIZE structure.*/
    template<typename T = ::Windows::Data::Common::Size>
    SIZE win32_size_from_bond(const T& input)
    {
        SIZE output;
        output.cx = input.cx;
        output.cy = input.cy;
        return output;
    }

    /** Converts a Win32 SIZE structure into a Windows::Data::Common::Size instance.
    @tparam T Windows::Data::Common::Size.  This type is typically inferred by the compiler.
    @param[in] input The Win32 SIZE structure to convert.
    @result An equivalent Windows::Data::Common::Size instance.*/
    template<typename T = ::Windows::Data::Common::Size>
    T bond_size_from_win32(const SIZE& input)
    {
        ::Windows::Data::Common::Size output;
        output.cx = input.cx;
        output.cy = input.cy;
        return output;
    }

#pragma endregion // Size
#pragma region Time

    /** Converts a uint64_t instance to a Win32 FILETIME structure.
    @param[in] input The uint64_t to convert.
    @result An equivalent Win32 FILETIME structure.*/
    inline FILETIME win32_time_from_bond(const uint64_t& input)
    {
        ULARGE_INTEGER largeInteger;
        largeInteger.QuadPart = input;
        FILETIME output;
        output.dwLowDateTime = largeInteger.LowPart;
        output.dwHighDateTime = largeInteger.HighPart;
        return output;
    }

    /** Converts a Win32 FILETIME structure into a uint64_t instance.
    @param[in] input The Win32 FILETIME structure to convert.
    @result An equivalent uint64_t.*/
    inline uint64_t bond_time_from_win32(const FILETIME& input)
    {
        ULARGE_INTEGER largeInteger;
        largeInteger.LowPart = input.dwLowDateTime;
        largeInteger.HighPart = input.dwHighDateTime;
        return largeInteger.QuadPart;
    }

#pragma endregion // Time
#pragma region GUID

    /** Converts a bond::GUID to a Win32 GUID.
    @tparam T bond::GUID.  This type is typically inferred by the compiler.
    @param[in] input The bond::GUID to convert.
    @result An equivalent Win32 GUID.*/
    template<typename T = ::bond::GUID>
    inline GUID win32_guid_from_bond(const T& input)
    {
        static_assert(sizeof(T) == sizeof(GUID), "Size mismatch");
        return *reinterpret_cast<const GUID*>(&input);
    }

    /** Converts a Win32 GUID into a bond::Guid.
    @tparam T bond::GUID.  This type is typically inferred by the compiler.
    @param[in] input The Win32 GUID structure to convert.
    @result An equivalent bond::GUID.*/
    template<typename T = ::bond::GUID>
    inline T bond_guid_from_win32(const GUID& input)
    {
        static_assert(sizeof(::bond::GUID) == sizeof(GUID), "Size mismatch");
        return *reinterpret_cast<const ::bond::GUID*>(&input);
    }

#pragma endregion // GUID
#pragma endregion // Conversion routines
} // namespace wil
