/********************************************************
*                                                       *
*   Copyright (C) Microsoft. All rights reserved.       *
*                                                       *
********************************************************/
#include "precomp.h"

#include "..\..\inc\consoletaeftemplates.hpp"

#include <memory>
#include <utility>
#include <iostream>

class KeyPressTests
{
    TEST_CLASS(KeyPressTests);

    // TODO: MSFT: 10187614 - Fix this test or the console code.
    //TEST_METHOD(TestAltGr)
    //{
    //    Log::Comment(L"Testing that alt-gr behavior hasn't changed");
    //    BOOL successBool;
    //    HWND hwnd = GetConsoleWindow();
    //    VERIFY_IS_NOT_NULL(hwnd);
    //    HANDLE inputHandle = GetStdHandle(STD_INPUT_HANDLE);
    //    DWORD events = 0;

    //    // flush input buffer
    //    FlushConsoleInputBuffer(inputHandle);
    //    successBool = GetNumberOfConsoleInputEvents(inputHandle, &events);
    //    VERIFY_IS_TRUE(!!successBool);
    //    VERIFY_ARE_EQUAL(events, 0);

    //    // send alt-gr + q keypress (@ on german keyboard)
    //    DWORD repeatCount = 1;
    //    SendMessage(hwnd,
    //                WM_CHAR,
    //                0x51, // q
    //                repeatCount | HIWORD(KF_EXTENDED | KF_ALTDOWN));
    //    // make sure the the keypresses got processed
    //    events = 0;
    //    successBool = GetNumberOfConsoleInputEvents(inputHandle, &events);
    //    VERIFY_IS_TRUE(!!successBool);
    //    VERIFY_IS_GREATER_THAN(events, 0u, NoThrowString().Format(L"%d", events));
    //    std::unique_ptr<INPUT_RECORD[]> inputBuffer = std::make_unique<INPUT_RECORD[]>(1);
    //    VERIFY_WIN32_BOOL_SUCCEEDED_RETURN(PeekConsoleInput(inputHandle,
    //                                                        inputBuffer.get(),
    //                                                        1,
    //                                                        &events));
    //    VERIFY_ARE_EQUAL(events, 1);

    //    INPUT_RECORD expectedEvent;
    //    expectedEvent.EventType = KEY_EVENT;
    //    expectedEvent.Event.KeyEvent.bKeyDown = !!true;
    //    expectedEvent.Event.KeyEvent.wRepeatCount = 1;
    //    expectedEvent.Event.KeyEvent.wVirtualKeyCode = 0;
    //    expectedEvent.Event.KeyEvent.wVirtualScanCode = 0;
    //    expectedEvent.Event.KeyEvent.dwControlKeyState = 32;
    //    expectedEvent.Event.KeyEvent.uChar.UnicodeChar = L'Q';
    //    // compare values against those that have historically been
    //    // returned with the same arguments to SendMessage
    //    VERIFY_ARE_EQUAL(expectedEvent, inputBuffer[0]);
    //}

    TEST_METHOD(TestCoalesceSameKeyPress)
    {
        Log::Comment(L"Testing that key events are properly coalesced when the same key is pressed repeatedly");
        BOOL successBool;
        HWND hwnd = GetConsoleWindow();
        VERIFY_IS_NOT_NULL(hwnd);
        HANDLE inputHandle = GetStdHandle(STD_INPUT_HANDLE);
        DWORD events = 0;

        // flush input buffer
        FlushConsoleInputBuffer(inputHandle);
        successBool = GetNumberOfConsoleInputEvents(inputHandle, &events);
        VERIFY_IS_TRUE(!!successBool);
        VERIFY_ARE_EQUAL(events, 0);

        // send a bunch of 'a' keypresses to the console
        DWORD repeatCount = 1;
        const unsigned int messageSendCount = 1000;
        for (unsigned int i = 0; i < messageSendCount; ++i)
        {
            SendMessage(hwnd,
                        WM_CHAR,
                        0x41,
                        repeatCount);
        }

        // make sure the the keypresses got processed and coalesced
        events = 0;
        successBool = GetNumberOfConsoleInputEvents(inputHandle, &events);
        VERIFY_IS_TRUE(!!successBool);
        VERIFY_IS_GREATER_THAN(events, 0u, NoThrowString().Format(L"%d", events));
        std::unique_ptr<INPUT_RECORD[]> inputBuffer = std::make_unique<INPUT_RECORD[]>(1);
        PeekConsoleInput(inputHandle,
                         inputBuffer.get(),
                         1,
                         &events);
        VERIFY_ARE_EQUAL(events, 1);
        VERIFY_ARE_EQUAL(inputBuffer[0].EventType, KEY_EVENT);
        VERIFY_ARE_EQUAL(inputBuffer[0].Event.KeyEvent.wRepeatCount, messageSendCount, NoThrowString().Format(L"%d", inputBuffer[0].Event.KeyEvent.wRepeatCount));
    }


    TEST_METHOD(TestCtrlUpDown)
    {
        Log::Comment(L"Testing the right number of input events is generated by Ctrl+Key press");
        BOOL successBool;
        HWND hwnd = GetConsoleWindow();
        VERIFY_IS_NOT_NULL(hwnd);
        HANDLE inputHandle = GetStdHandle(STD_INPUT_HANDLE);
        DWORD events = 0;

        // flush input buffer
        FlushConsoleInputBuffer(inputHandle);
        successBool = GetNumberOfConsoleInputEvents(inputHandle, &events);
        VERIFY_IS_TRUE(!!successBool);
        VERIFY_ARE_EQUAL(events, 0);

        DWORD dwInMode = 0;
        GetConsoleMode(inputHandle, &dwInMode);
        Log::Comment(NoThrowString().Format(L"Mode:0x%x", dwInMode));
        // send a bunch of 'a' keypresses to the console
        // DWORD repeatCount = 1;
        // const unsigned int messageSendCount = 1000;
        // for (unsigned int i = 0; i < messageSendCount; ++i)
        // {
        //     SendMessage(hwnd,
        //                 WM_CHAR,
        //                 0x41,
        //                 repeatCount);
        // }


        // SendMessage(hwnd, 0x0100, 0x11, 1); // keydown ctrl
        // SendMessage(hwnd, 0x0100, 0x53, 1); // keydown S
        // SendMessage(hwnd, 0x0101, 0x53, 1); // keyup s
        // SendMessage(hwnd, 0x0101, 0x11, 1); // keyup ctrl  


        for (WORD vk = 0x41; vk <= 0x5A; vk ++)
        {

            if (vk == 'A') continue; // Selects Text
            if (vk == 'C') continue; // Exits window
            if (vk == 'F') continue; // Opens Find Dialog
            if (vk == 'M') continue; // Enters Mark Mode
            if (vk == 'S') continue; // Ignores the next key? C-s -> DC3
            if (vk == 'V') continue; // Pastes
            // UINT vkCtrl = VK_CONTROL;
            UINT vkCtrl = VK_LCONTROL;
            UINT uiScancode = MapVirtualKey(vk , MAPVK_VK_TO_VSC);
            UINT uiCtrlScancode = MapVirtualKey(vkCtrl , MAPVK_VK_TO_VSC);
            LPARAM flags = ( 0 | ((uiScancode<<16) & 0x00ff0000) | 0x00000001);
            LPARAM CtrlFlags = ( 0 | ((uiCtrlScancode<<16) & 0x00ff0000) | 0x00000001);
            // LPARAM CtrlFlags = 0 | ((uiCtrlScancode&0xff) << 16);

            LPARAM upFlags = flags | 0xc0000000;
            LPARAM upCtrlFlags = CtrlFlags | 0xc0000000;

            Log::Comment(NoThrowString().Format(L"Testing Ctrl+%c", vk));
            Log::Comment(NoThrowString().Format(L"flags=0x%x, CtrlFlags=0x%x", flags, CtrlFlags));
            Log::Comment(NoThrowString().Format(L"upFlags=0x%x, upCtrlFlags=0x%x", upFlags, upCtrlFlags));
            // {
            //     PostMessage(hwnd, WM_KEYDOWN,   vkCtrl,     CtrlFlags);
            //     PostMessage(hwnd, WM_KEYDOWN,   vk,         flags);
            //     // PostMessage(hwnd, WM_CHAR,      vk-0x40,    flags); 
            //     PostMessage(hwnd, WM_KEYUP,     vk,         upFlags);
            //     PostMessage(hwnd, WM_KEYUP,     vkCtrl,     upCtrlFlags); 
            // }
            {
                SendMessage(hwnd, WM_KEYDOWN,   vkCtrl,     CtrlFlags);
                SendMessage(hwnd, WM_KEYDOWN,   vk,         flags);
                // SendMessage(hwnd, WM_CHAR,      vk-0x40,    flags); 
                SendMessage(hwnd, WM_KEYUP,     vk,         upFlags);
                SendMessage(hwnd, WM_KEYUP,     vkCtrl,     upCtrlFlags); 
            }
            // {
            //     SendMessage(hwnd, WM_KEYDOWN, VK_LCONTROL, 0); // keydown ctrl
            //     SendMessage(hwnd, WM_KEYDOWN,   vk, 0); // keydown S
            //     SendMessage(hwnd, WM_KEYUP,   vk, 1); // keyup s
            //     SendMessage(hwnd, WM_KEYUP, VK_LCONTROL, 1); // keyup ctrl  
            // }
            
            // {
            //     // This doesn't work because of the whole backgrounding thing.
            //     //   The window gets bg'ed by the
            //     KEYBDINPUT kbdIn = {0};
            //     INPUT in = {0};
            //     in.type = INPUT_KEYBOARD;
                
            //     kbdIn.wVk = 0x11;
            //     in.ki = kbdIn;
            //     SendInput(1, &in, sizeof(in));

            //     kbdIn.wVk = vk;
            //     in.ki = kbdIn;
            //     SendInput(1, &in, sizeof(in));

            //     kbdIn.dwFlags = KEYEVENTF_KEYUP;
            //     in.ki = kbdIn;
            //     SendInput(1, &in, sizeof(in));

            //     kbdIn.wVk = 0x11;
            //     in.ki = kbdIn;
            //     SendInput(1, &in, sizeof(in));
            // }

            Sleep(100);

            events = 0;
            successBool = GetNumberOfConsoleInputEvents(inputHandle, &events);
            VERIFY_IS_TRUE(!!successBool);
            VERIFY_IS_GREATER_THAN(events, 0u, NoThrowString().Format(L"%d events found", events));

            std::unique_ptr<INPUT_RECORD[]> inputBuffer = std::make_unique<INPUT_RECORD[]>(16);
            PeekConsoleInput(inputHandle,
                             inputBuffer.get(),
                             16,
                             &events);

            for (size_t i = 0; i < events; i++)
            {
                INPUT_RECORD rc = inputBuffer[i];
                switch (rc.EventType)
                {
                    case KEY_EVENT:
                    {
                        Log::Comment(NoThrowString().Format(
                            L"Down: %d Repeat: %d KeyCode: 0x%x ScanCode: 0x%x Char: %c (0x%x) KeyState: 0x%x",
                            rc.Event.KeyEvent.bKeyDown,
                            rc.Event.KeyEvent.wRepeatCount,
                            rc.Event.KeyEvent.wVirtualKeyCode,
                            rc.Event.KeyEvent.wVirtualScanCode,
                            rc.Event.KeyEvent.uChar.UnicodeChar != 0 ? rc.Event.KeyEvent.uChar.UnicodeChar : ' ',
                            rc.Event.KeyEvent.uChar.UnicodeChar,
                            rc.Event.KeyEvent.dwControlKeyState
                        ));

                        break;
                    }
                    default:
                        Log::Comment(NoThrowString().Format(L"Another event type was found."));
                }
            }
            VERIFY_ARE_EQUAL(events, 4);
            VERIFY_ARE_EQUAL(inputBuffer[0].EventType, KEY_EVENT);
            VERIFY_ARE_EQUAL(inputBuffer[1].EventType, KEY_EVENT);
            VERIFY_ARE_EQUAL(inputBuffer[2].EventType, KEY_EVENT);
            VERIFY_ARE_EQUAL(inputBuffer[3].EventType, KEY_EVENT);

            // VERIFY_ARE_EQUAL(inputBuffer[1].Event.KeyEvent.wVirtualKeyCode, inputBuffer[1].Event.KeyEvent.uChar.UnicodeChar + 0x40);
            
            // VERIFY_ARE_EQUAL(inputBuffer[1].Event.KeyEvent.wVirtualKeyCode, inputBuffer[2].Event.KeyEvent.wVirtualKeyCode);
            // VERIFY_ARE_EQUAL(inputBuffer[0].Event.KeyEvent.wVirtualKeyCode, inputBuffer[3].Event.KeyEvent.wVirtualKeyCode);
            // VERIFY_ARE_EQUAL(inputBuffer[0].Event.KeyEvent.wRepeatCount, 1, NoThrowString().Format(L"%d", inputBuffer[0].Event.KeyEvent.wRepeatCount));

            FlushConsoleInputBuffer(inputHandle);
        }


    }

};